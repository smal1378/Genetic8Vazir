# Genetic8Vazir
Genetic Algorithm for solving 8-Queens puzzle.
<br>
Ver: 1.0
<br>
Jump into `How To Run` section if you don't care about details.
---
### Question:
How to place 8 chess queens in a chessboard so that no two queens threaten each other.
<br>
So no two queens should be in a same column, row or diagonal.

---
### Solution:
I'm using a very simple binary genetic algorithm to solve this puzzle and present an answer.
<br>
The answer should be places of eight queens in the 8x8 chessboard that will show up on screen.
<br>
Well assuming that you know what is a binary genetic algorithm I'll start with some definition:
#### Chromosome
I'm using a 64bits (each bit can be zero or one) to present an answer or a solution to the problem. which is called a
chromosome! There is a class Chromosome that is defined in `genetic.py`.
<br>
These 64 bits are divided into 8 group of 8bits. Each group has only one `1` and the others are `0`, 
The `1` presents a queen in a row. So there is eight queens that each one is in a separate row.

#### Fittness Function
Best answer is a chromosome that no queens threaten another one.
So to find out how bad is a chromosome I'll calculate how many queens threat another one, 
It means that for each queen calculate that how many queens are in the same row, column or diagonal.
<br>
To find out how good is this chromosome, we can use this formula: `fittness = 64 - threats`.
<br>
If you want to ask why, Just because I'm saying it... (I'm pretty sure that total threatens won't be greater than 64)

#### Algorithm Parameters
There are some parameters that you can change in algorithm, I'll explain theme one by one: <br>
Note: Most numbers are guessed by me and tried so many times to find them out.
- population: Total chromosomes that are in each generation. 
1000 is good and 2000 is perfect, Getting lower than 500 causes unstable average fittness. 
With some tests I found that the more this number is the more stable population we got.
- max_iter: Maximum iteration (or generations) within each run of algorithm. 800 for default, but 200 usually works.
- min_iter: Minimum iteration even that a chromosome with fittness value of 64 found.
Set this to 200 if you want to see the plots that show how population gets close to answer by generation. 
Use 0 to avoid extra calculations.
- pc: Possibility of recombine, This number shows how much is this possible that two parents create new children,
A number between `0.0` to `1.0`, Default is `0.8`.
- lower_pc: How much pc parameter get lower within each generation, 
In a genetic algorithm it's a good choice to lower the chance of change in chromosome, 
Lower jumps is better at the end, Default is `0`, But it looks like that `0.001` works perfect for default parameters.
- pm: Possibility of mutation, for each chromosome while performing new generation there is a possibility of
mutating new chromosome, these mutations are big jump in answers area. Using a high possibility will cause the 
population to change too much within generations. The default is very low `0.005`.
- lower_pm: How much pm parameter get lower within each generation,
Default is `0`. As the default pm parameter is low you can set it to higher numbers like `0.5` and 
set this parameter to `0.009`, Doing this configuration will cause big jumps in first start and very low 
jumps at the end which is kinda perfect (at least in plots).
- max_fittness: This number sets the algorithm to stop generating (iterating) when the best chromosome fittness 
reached to it. Default is `64` meaning while there is a chromosome that has fittness value of 64 terminate the 
algorithm. (only if min_iter has reached), choose a number greater than 64 so that algorithm keep generating 
until max_iter.

#### Evaluate Initial Population
Initial population or the 1'th generation will be created by calling `genetic.Genetic._evaluate_population`.
This call will be made in `gentic.Genetic.__init__` and that's why it's encapsulated 
(started with an underline). <br>
It will create random chromosomes and appends them to the population list.

#### Parent Selection
I'm using roulette wheel selection. In this selection type each chromosome has a chance by its own fittness value.
It means that if a chromosome has a 20 fittness value, and the other has 40, Other might be chosen
two times more than the first.
<br>
First a list containing a tuple `(fittness sum till here, chromosome)` will be created. 
Then a number between zero and sum of total fittness values will be generated by random.
Finally, a for loop moves from first tuple in list to the end until one or first element in tuple is 
greater than the number, that chromosome will be chosen.

#### Recombine or Crossover
With having two parents I'm using `one point cross over`. A random number between 0 and 8 will be generated, 
this number will be multiplied by 8, The result will be 0, 8, 16 and... and shows which row to cut from.
<br> 
Using this random number rows before this number from first parend joining rows after this number from second parent
will create first child chromosome, And just like first child, Second child is created from rows after the number 
from first parend and rows before the number from second parend.
Crossing over will be done by the possibility of `pc` parameter value. If two parents doesn't get the chance to 
crossover they will be moved to next generation.
This method is defined under `genetic.Chromosome.new` and will be called in `genetic.Genetic.recombine`.

#### Mutation
For each chromosome that is going to next generation population method `genetic.Chromosom.mutate` will be called 
from `genetic.Genetic.next_generation`.
<br>
Calling this method doesn't mean that mutation will occur, method will mutate the chromosome by the chance 
of `pm` parameter value.
<br>
Mutating a chromosome is just changing one queens place in a row, a number from 0 to 64 will be generated and 
if that index was `1` meaning there is a queen there, it will make it `0` and randomly make another index
in the same row `1`.

#### Generating New Population
After choosing some parents and creating new childes, my code uses the simplest way to generate new population.
<br>
New population will be exactly the new childes created. (I know it's bad just don't keep saying it to me,
fix it if you like and send a pull request)
<br> 
With this, I had to choose exactly the same number of parents in parent selection part as the population 
to avoid population size change during generations.

---
That was how exactly the algorithm work. There are some other details that I might add them to this readme later.

### How To Run:
Simply just double-click on `runner.py`.
<br>
Note that you should install `matplotlib` module if you didn't yet.
<br><br>
Some details:
- Find `repeat` variable, It's default is `1` means the algorithm will run only one time, 
My teacher said to me that a genetic algorithm should run like `30` times to make sure you find the best answer, 
With default parameters at 99% of times you'll get the answer with only one run.
- Algorithm parameters are being set in first few lines of `runner.py`. 
Try running algorithm with many combination of parameters and see the result.
- After running the `runner.py` there will be some progressbar showing how many generation has been proceeded. 
- After algorithm has finished, Three plots will appear on your screen, First (starting from top left) is 
the chessboard, Black squares are queens. Second plot is best fittness found in a population by generation. 
Third is fittness average by generation, This plot might go up and down in lower generations but will stay stable
at remaining generations (Assume it 30 by 70) (And ofcourse with default parameters, If it wasn't means 
algorithm is not working good.)


### Some Experiences That I Achieved

--- I'll write it later ---

<br><br><br>
Good luck.